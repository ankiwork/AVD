/**-----------------------------------------------
 * RCColor.c
 * This file is automatically generated, don't try to edit it
 * all modifications will be lost with changing color resource
 **-----------------------------------------------*/

#include <RCColor.h>
#include <UserCAPI.h>

#define RCCOLOR_OFFSET 512

// cppcheck-suppress unmatchedSuppression
// cppcheck-suppress unusedFunction
uint32_t RCColorGetColor(uint16_t cSchemeID, uint16_t cNameID)
{
  if ((0xFFFF == cSchemeID) && (0xFFFF == cNameID))
  {
    if ((RCCOLOR_MAX_SCHEMES > 0) && (RCCOLOR_MAX_NAMES > 0))
    {
      return RCCOLOR_OFFSET;
    }
    else
    {
      return 0;
    }
  }
  
  // cppcheck-suppress unmatchedSuppression
  // cppcheck-suppress unsignedLessThanZero
  if ((RCCOLOR_MAX_SCHEMES >= (cSchemeID + 1)) && (RCCOLOR_MAX_NAMES >= (cNameID + 1)))
  {
    uint32_t offset = RCCOLOR_OFFSET;
    const uint8_t *resourceBaseAdr = GetResDataBase();
    
    const uint16_t *colorTabHdr = (const uint16_t *)(const void *)(resourceBaseAdr + offset);
    uint16_t numbColorS = colorTabHdr[0];  // number of color schemes
    uint16_t numbColorN = colorTabHdr[1];  // number of color names
    if (cSchemeID >= numbColorS) {cSchemeID = numbColorS - 1;}
    if (cNameID >= numbColorN) {cNameID = numbColorN - 1;}
    
    const uint32_t *colorTab = (const uint32_t *)(const void *)(resourceBaseAdr + offset + 4);  // skip header (4 byte, see above)
    uint32_t c = colorTab[cSchemeID * numbColorN + cNameID];
    return c;
  }
  return 0xFFABABAB;
}
//-------------------------------------------------

// cppcheck-suppress unmatchedSuppression
// cppcheck-suppress unusedFunction
void RCColorSetColor(uint16_t cSchemeID, uint16_t cNameID, uint32_t c)
{
  // cppcheck-suppress unmatchedSuppression
  // cppcheck-suppress unsignedLessThanZero
  if ((RCCOLOR_MAX_SCHEMES >= (cSchemeID + 1)) && (RCCOLOR_MAX_NAMES >= (cNameID + 1)))
  {
    uint32_t offset = RCCOLOR_OFFSET;
    uint8_t *resourceBaseAdr = (uint8_t *)GetResDataBase();
    
    uint16_t *colorTabHdr = (uint16_t *)(void *)(resourceBaseAdr + offset);
    uint16_t numbColorS = colorTabHdr[0];  // number of color schemes
    uint16_t numbColorN = colorTabHdr[1];  // number of color names
    if (cSchemeID >= numbColorS) {cSchemeID = numbColorS - 1;}
    if (cNameID >= numbColorN) {cNameID = numbColorN - 1;}
    
    uint32_t *colorTab = (uint32_t *)(void *)(resourceBaseAdr + offset + 4);  // skip header (4 byte, see above)
    uint32_t oldColor = colorTab[cSchemeID * numbColorN + cNameID];
    colorTab[cSchemeID * numbColorN + cNameID] = (c | 0xFF000000);
    
    if (colorTab[cSchemeID * numbColorN + cNameID] != oldColor)
    {
      // Event werfen, wird im Accessor gefangen und setzt dort ebenfalls die Farbe
      tUserCEvt e;
      e.Type = CEVT_RCCOLOR_CHANGE;
      e.Source = CEVT_SOURCE_VISU;
      e.Content.mRCColorChange.mSchemeID = cSchemeID;
      e.Content.mRCColorChange.mNameID = cNameID;
      e.Content.mRCColorChange.mOldColor = oldColor;
      e.Content.mRCColorChange.mNewColor = colorTab[cSchemeID * numbColorN + cNameID];
      e.Content.mRCColorChange.mOffset = offset;
      RaiseUserCEvent(&e);
    }
  }
}
//-------------------------------------------------

