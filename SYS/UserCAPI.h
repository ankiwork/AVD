/**
 * @file
 *
 * This file is the API usable by UserC programs of MCQ projects. This file is
 * generated by UserCAPIUpdate.pl and should not edited manually. If new
 * functions should be added to the UserC interface add them to UserCAPI.gen.h
 * and call the script.
 *
 * @author UserCAPIUpdate.pl<br>
 *         Graf-Syteco GmbH & Co. KG
 */

#ifndef USERCAPI_H_INCLUDED
#define USERCAPI_H_INCLUDED

//-----------------------------------------------------------------------------
//Includes
//-----------------------------------------------------------------------------
#include <stdint.h>
#include <stdarg.h>
#include <stddef.h>

#ifdef GDSPROJECT
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <math.h>
#include "UserCEvents.h"
#else /* GDSPROJECT */
#include <gs/UserCAPI/UserCEvents.h>
#endif /* GDSPROJECT */

//-----------------------------------------------------------------------------
//Defines
//-----------------------------------------------------------------------------
#define GS_FILE_SEEK_SET                    0       //!< Seek relativ to file start (SEEK_SET)
#define GS_FILE_SEEK_CUR                    1       //!< Seek relativ to current position (SEEK_CUR)
#define GS_FILE_SEEK_END                    2       //!< Seek relativ to file end (SEEK_END)

#define GS_PRJ_UPDATE_REJECT                0       //!< Reject a project update
#define GS_PRJ_UPDATE_ACCEPT                1       //!< Accept a earlier rejected project update
#define GS_PRJ_UPDATE_TRIGGER               2       //!< Trigger a project update

#define GS_SCREENSHOT_SRC_VISU              0       //!< Creates a screenshot from the visualization
#define GS_SCREENSHOT_SRC_VIDEO0            1       //!< Creates a screenshot from video channel 0
#define GS_SCREENSHOT_SRC_VIDEO1            2       //!< Creates a screenshot from video channel 1

#define GS_KEY_BACKLIGHT_OFF                0       //!< All key beacklights of
#define GS_KEY_BACKLIGHT_WHITE              (1<<0)  //!< White key backlight on
#define GS_KEY_BACKLIGHT_RED                (1<<1)  //!< Red key backlight on
#define GS_KEY_BACKLIGHT_GREEN              (1<<2)  //!< Green key backlight on
#define GS_KEY_BACKLIGHT_BRIGHTNESS(x)      (((100 - (x)) & 0xFF) << 24)  //!< Percentage of dimming (0 - 100)

#define GS_KEY_TO_VISU_OP_MASK              ((3U<<30) | (3U<<26))
#define GS_KEY_TO_VISU_OP_DOWNUP            ((0U<<30) | (0U<<26))
#define GS_KEY_TO_VISU_OP_DOWN              ((1U<<30) | (0U<<26))
#define GS_KEY_TO_VISU_OP_UP                ((2U<<30) | (0U<<26))
#define GS_KEY_TO_VISU_OP_UPDOWN            ((3U<<30) | (0U<<26))
#define GS_KEY_TO_VISU_OP_REPEAT            ((0U<<30) | (1U<<26))

#define GS_KEY_TO_VISU_TYPE_MASK            (3U<<28)
#define GS_KEY_TO_VISU_TYPE_KEY             (0U<<28)
#define GS_KEY_TO_VISU_TYPE_LKF             (1U<<28)
#define GS_KEY_TO_VISU_TYPE_UNICODE         (2U<<28)

#define GS_KEY_TO_VISU_DOWNUP(k)            (GS_KEY_TO_VISU_OP_DOWNUP | (k))
#define GS_KEY_TO_VISU_DOWN(k)              (GS_KEY_TO_VISU_OP_DOWN   | (k))
#define GS_KEY_TO_VISU_UP(k)                (GS_KEY_TO_VISU_OP_UP     | (k))
#define GS_KEY_TO_VISU_UPDOWN(k)            (GS_KEY_TO_VISU_OP_UPDOWN | (k))
#define GS_KEY_TO_VISU_REPEAT(k)            (GS_KEY_TO_VISU_OP_REPEAT | (k))

#define GS_INIT_FLAG_FIRST_PROJECT_START    (1<<0)  //!< Indicates first start of a project

#define GS_POWER_CMD_DISPLAY_OFF            1
#define GS_POWER_CMD_DISPLAY_ON             2
#define GS_POWER_CMD_REBOOT                 3
#define GS_POWER_CMD_STANDBY                4

#define GS_STANDBY_WAKEUP_IGNITION          (1<<0)
#define GS_STANDBY_WAKEUP_KEYS              (1<<1)

#define GS_CAN_DATA_FRAME                   0
#define GS_CAN_RTR_FRAME                    1
#define GS_CAN_NON_GREEDY_FILTER            (1<<30)

#define GS_SEND_KEY_UP                      0
#define GS_SEND_KEY_DOWN                    1
#define GS_SEND_KEY_REPEAT                  2

#define GS_SEND_TOUCH_UP                    0
#define GS_SEND_TOUCH_DOWN                  1
#define GS_SEND_TOUCH_ON                    2

#define GS_SEND_TOUCH_TO_VISU               (1<<0)
#define GS_SEND_TOUCH_TO_CTRL               (1<<1)

#define GS_RMA_INITIALIZED                  0
#define GS_RMA_LOADED                       1
#define GS_RMA_CROPPED                      2
#define GS_RMA_PADDED                       3
#define GS_RMA_FREED                        4
#define GS_RMA_OUT_OF_MEM                   -1
#define GS_RMA_ERROR                        -2
#define GS_RMA_ALREADY_ATTACHED             -3

#define GS_RMA_FLAG_AUTOMATIC               (1<<0)
#define GS_RMA_FLAG_KEEP_ON_RESIZE          (1<<1)

//Buzzer mode is a bitfield with the following valid bits:
//0-3   Mode of the buzzer. See GS_BUZZER_MODE_*
//4-19  Frequency of the buzzer (0 for default)
//28-31 Which buzzer (if multiple are available)
#define GS_BUZZER_MODE_OFF                  0   //!< The buzzer is off
#define GS_BUZZER_MODE_ON                   1   //!< The buzzer is on
#define GS_BUZZER_MODE_LOUD                 2   //!< The buzzer is on and tries to be louder (depending on hardware)
#define GS_BUZZER_MODE(n, m, freq)          (((n) & 0xF) << 28) | ((m) & 0xF) | (((freq) & 0xFFFF) << 4)

#define GS_ARRAYELEMENTS(x)                 (sizeof(x) / sizeof(*(x)))

#ifndef EXPORTFROMSO
#define EXPORTFROMSO __attribute__ ((visibility ("default")))
#endif //EXPORTFROMSO

#ifdef GDSPROJECT
#ifndef NULL
#define NULL ((void *)0)
#endif //NULL
#endif //GDSPROJECT

#if defined GDSPROJECT
//GetVar
#ifdef GetVar
#undef GetVar
#endif
#define GetVar _gs_api_GetVarTrampoline

//GetVarIndex
#ifdef GetVarIndex
#undef GetVarIndex
#endif
#define GetVarIndex _gs_api_GetVarIndexTrampoline

//GetVarHandle
#ifdef GetVarHandle
#undef GetVarHandle
#endif
#define GetVarHandle _gs_api_GetVarHandleTrampoline

//GetVarIndexed
#ifdef GetVarIndexed
#undef GetVarIndexed
#endif
#define GetVarIndexed _gs_api_GetVarIndexedTrampoline

//SetVar
#ifdef SetVar
#undef SetVar
#endif
#define SetVar _gs_api_SetVarTrampoline

//SetVarIndexed
#ifdef SetVarIndexed
#undef SetVarIndexed
#endif
#define SetVarIndexed _gs_api_SetVarIndexedTrampoline

//GetVarFloat
#ifdef GetVarFloat
#undef GetVarFloat
#endif
#define GetVarFloat _gs_api_GetVarFloatTrampoline

//SetVarFloat
#ifdef SetVarFloat
#undef SetVarFloat
#endif
#define SetVarFloat _gs_api_SetVarFloatTrampoline

//GetVisibleVarsIndieces
#ifdef GetVisibleVarsIndieces
#undef GetVisibleVarsIndieces
#endif
#define GetVisibleVarsIndieces _gs_api_GetVisibleVarsIndiecesTrampoline

//LoadParameterSet
#ifdef LoadParameterSet
#undef LoadParameterSet
#endif
#define LoadParameterSet _gs_api_LoadParameterSetTrampoline

//SaveParameterSet
#ifdef SaveParameterSet
#undef SaveParameterSet
#endif
#define SaveParameterSet _gs_api_SaveParameterSetTrampoline

//VarEnableEvent
#ifdef VarEnableEvent
#undef VarEnableEvent
#endif
#define VarEnableEvent _gs_api_VarEnableEventTrampoline

//VarDisableEvent
#ifdef VarDisableEvent
#undef VarDisableEvent
#endif
#define VarDisableEvent _gs_api_VarDisableEventTrampoline

//VarIsEventEnabled
#ifdef VarIsEventEnabled
#undef VarIsEventEnabled
#endif
#define VarIsEventEnabled _gs_api_VarIsEventEnabledTrampoline

//MsgContainerOn
#ifdef MsgContainerOn
#undef MsgContainerOn
#endif
#define MsgContainerOn _gs_api_MsgContainerOnTrampoline

//MsgContainerOnPos
#ifdef MsgContainerOnPos
#undef MsgContainerOnPos
#endif
#define MsgContainerOnPos _gs_api_MsgContainerOnPosTrampoline

//MsgContainerOff
#ifdef MsgContainerOff
#undef MsgContainerOff
#endif
#define MsgContainerOff _gs_api_MsgContainerOffTrampoline

//InfoContainerOn
#ifdef InfoContainerOn
#undef InfoContainerOn
#endif
#define InfoContainerOn _gs_api_InfoContainerOnTrampoline

//InfoContainerOnPos
#ifdef InfoContainerOnPos
#undef InfoContainerOnPos
#endif
#define InfoContainerOnPos _gs_api_InfoContainerOnPosTrampoline

//InfoContainerOff
#ifdef InfoContainerOff
#undef InfoContainerOff
#endif
#define InfoContainerOff _gs_api_InfoContainerOffTrampoline

//GetVisibleInfoContainers
#ifdef GetVisibleInfoContainers
#undef GetVisibleInfoContainers
#endif
#define GetVisibleInfoContainers _gs_api_GetVisibleInfoContainersTrampoline

//MaskOn
#ifdef MaskOn
#undef MaskOn
#endif
#define MaskOn _gs_api_MaskOnTrampoline

//MaskOff
#ifdef MaskOff
#undef MaskOff
#endif
#define MaskOff _gs_api_MaskOffTrampoline

//PrioMaskOn
#ifdef PrioMaskOn
#undef PrioMaskOn
#endif
#define PrioMaskOn _gs_api_PrioMaskOnTrampoline

//IsMsgContainerOn
#ifdef IsMsgContainerOn
#undef IsMsgContainerOn
#endif
#define IsMsgContainerOn _gs_api_IsMsgContainerOnTrampoline

//IsInfoContainerOn
#ifdef IsInfoContainerOn
#undef IsInfoContainerOn
#endif
#define IsInfoContainerOn _gs_api_IsInfoContainerOnTrampoline

//IsMaskOn
#ifdef IsMaskOn
#undef IsMaskOn
#endif
#define IsMaskOn _gs_api_IsMaskOnTrampoline

//ProcessMaskContainerRequests
#ifdef ProcessMaskContainerRequests
#undef ProcessMaskContainerRequests
#endif
#define ProcessMaskContainerRequests _gs_api_ProcessMaskContainerRequestsTrampoline

//GetCurrentMaskShown
#ifdef GetCurrentMaskShown
#undef GetCurrentMaskShown
#endif
#define GetCurrentMaskShown _gs_api_GetCurrentMaskShownTrampoline

//GetCurrentMsgContainerShown
#ifdef GetCurrentMsgContainerShown
#undef GetCurrentMsgContainerShown
#endif
#define GetCurrentMsgContainerShown _gs_api_GetCurrentMsgContainerShownTrampoline

//RTCGetTime
#ifdef RTCGetTime
#undef RTCGetTime
#endif
#define RTCGetTime _gs_api_RTCGetTimeTrampoline

//RTCGetDate
#ifdef RTCGetDate
#undef RTCGetDate
#endif
#define RTCGetDate _gs_api_RTCGetDateTrampoline

//RTCSetTime
#ifdef RTCSetTime
#undef RTCSetTime
#endif
#define RTCSetTime _gs_api_RTCSetTimeTrampoline

//RTCSetDate
#ifdef RTCSetDate
#undef RTCSetDate
#endif
#define RTCSetDate _gs_api_RTCSetDateTrampoline

//SetDebugWindow
#ifdef SetDebugWindow
#undef SetDebugWindow
#endif
#define SetDebugWindow _gs_api_SetDebugWindowTrampoline

//PrintToDebug
#ifdef PrintToDebug
#undef PrintToDebug
#endif
#define PrintToDebug _gs_api_PrintToDebugTrampoline

//VPrintToDebug
#ifdef VPrintToDebug
#undef VPrintToDebug
#endif
#define VPrintToDebug _gs_api_VPrintToDebugTrampoline

//IsKeyDown
#ifdef IsKeyDown
#undef IsKeyDown
#endif
#define IsKeyDown _gs_api_IsKeyDownTrampoline

//IsAnyKeyDown
#ifdef IsAnyKeyDown
#undef IsAnyKeyDown
#endif
#define IsAnyKeyDown _gs_api_IsAnyKeyDownTrampoline

//IsKeyPressedNew
#ifdef IsKeyPressedNew
#undef IsKeyPressedNew
#endif
#define IsKeyPressedNew _gs_api_IsKeyPressedNewTrampoline

//IsKeyReleasedNew
#ifdef IsKeyReleasedNew
#undef IsKeyReleasedNew
#endif
#define IsKeyReleasedNew _gs_api_IsKeyReleasedNewTrampoline

//AddLogMessage
#ifdef AddLogMessage
#undef AddLogMessage
#endif
#define AddLogMessage _gs_api_AddLogMessageTrampoline

//AddLogVariable
#ifdef AddLogVariable
#undef AddLogVariable
#endif
#define AddLogVariable _gs_api_AddLogVariableTrampoline

//SetVideoInSourceViewport
#ifdef SetVideoInSourceViewport
#undef SetVideoInSourceViewport
#endif
#define SetVideoInSourceViewport _gs_api_SetVideoInSourceViewportTrampoline

//SetVideoInDestinationViewport
#ifdef SetVideoInDestinationViewport
#undef SetVideoInDestinationViewport
#endif
#define SetVideoInDestinationViewport _gs_api_SetVideoInDestinationViewportTrampoline

//SetVideoInParam
#ifdef SetVideoInParam
#undef SetVideoInParam
#endif
#define SetVideoInParam _gs_api_SetVideoInParamTrampoline

//SetVideoInOnOff
#ifdef SetVideoInOnOff
#undef SetVideoInOnOff
#endif
#define SetVideoInOnOff _gs_api_SetVideoInOnOffTrampoline

//CANAddRxFilterCallBack
#ifdef CANAddRxFilterCallBack
#undef CANAddRxFilterCallBack
#endif
#define CANAddRxFilterCallBack _gs_api_CANAddRxFilterCallBackTrampoline

//CANCreateFiFo
#ifdef CANCreateFiFo
#undef CANCreateFiFo
#endif
#define CANCreateFiFo _gs_api_CANCreateFiFoTrampoline

//CANRemoveFiFo
#ifdef CANRemoveFiFo
#undef CANRemoveFiFo
#endif
#define CANRemoveFiFo _gs_api_CANRemoveFiFoTrampoline

//CANRemoveCallBack
#ifdef CANRemoveCallBack
#undef CANRemoveCallBack
#endif
#define CANRemoveCallBack _gs_api_CANRemoveCallBackTrampoline

//CANAddRxFilterFiFo
#ifdef CANAddRxFilterFiFo
#undef CANAddRxFilterFiFo
#endif
#define CANAddRxFilterFiFo _gs_api_CANAddRxFilterFiFoTrampoline

//CANReadFiFo
#ifdef CANReadFiFo
#undef CANReadFiFo
#endif
#define CANReadFiFo _gs_api_CANReadFiFoTrampoline

//CANReadFiFoWait
#ifdef CANReadFiFoWait
#undef CANReadFiFoWait
#endif
#define CANReadFiFoWait _gs_api_CANReadFiFoWaitTrampoline

//CANReadFiFoWaitTo
#ifdef CANReadFiFoWaitTo
#undef CANReadFiFoWaitTo
#endif
#define CANReadFiFoWaitTo _gs_api_CANReadFiFoWaitToTrampoline

//CANSendMsg
#ifdef CANSendMsg
#undef CANSendMsg
#endif
#define CANSendMsg _gs_api_CANSendMsgTrampoline

//CANSendMsgWait
#ifdef CANSendMsgWait
#undef CANSendMsgWait
#endif
#define CANSendMsgWait _gs_api_CANSendMsgWaitTrampoline

//SetVisObjData
#ifdef SetVisObjData
#undef SetVisObjData
#endif
#define SetVisObjData _gs_api_SetVisObjDataTrampoline

//GetVisObjData
#ifdef GetVisObjData
#undef GetVisObjData
#endif
#define GetVisObjData _gs_api_GetVisObjDataTrampoline

//SerialSend
#ifdef SerialSend
#undef SerialSend
#endif
#define SerialSend _gs_api_SerialSendTrampoline

//SerialRecv
#ifdef SerialRecv
#undef SerialRecv
#endif
#define SerialRecv _gs_api_SerialRecvTrampoline

//SetDigitalOutput
#ifdef SetDigitalOutput
#undef SetDigitalOutput
#endif
#define SetDigitalOutput _gs_api_SetDigitalOutputTrampoline

//GetDigitalOutput
#ifdef GetDigitalOutput
#undef GetDigitalOutput
#endif
#define GetDigitalOutput _gs_api_GetDigitalOutputTrampoline

//GetDigitalOutputStatus
#ifdef GetDigitalOutputStatus
#undef GetDigitalOutputStatus
#endif
#define GetDigitalOutputStatus _gs_api_GetDigitalOutputStatusTrampoline

//SetPWMOutput
#ifdef SetPWMOutput
#undef SetPWMOutput
#endif
#define SetPWMOutput _gs_api_SetPWMOutputTrampoline

//GetAnalogInput
#ifdef GetAnalogInput
#undef GetAnalogInput
#endif
#define GetAnalogInput _gs_api_GetAnalogInputTrampoline

//SetAnalogInputType
#ifdef SetAnalogInputType
#undef SetAnalogInputType
#endif
#define SetAnalogInputType _gs_api_SetAnalogInputTypeTrampoline

//GetAnalogInputType
#ifdef GetAnalogInputType
#undef GetAnalogInputType
#endif
#define GetAnalogInputType _gs_api_GetAnalogInputTypeTrampoline

//GetAnalogInputStatus
#ifdef GetAnalogInputStatus
#undef GetAnalogInputStatus
#endif
#define GetAnalogInputStatus _gs_api_GetAnalogInputStatusTrampoline

//SetAnalogOutput
#ifdef SetAnalogOutput
#undef SetAnalogOutput
#endif
#define SetAnalogOutput _gs_api_SetAnalogOutputTrampoline

//GetDigitalInput
#ifdef GetDigitalInput
#undef GetDigitalInput
#endif
#define GetDigitalInput _gs_api_GetDigitalInputTrampoline

//GetFrequencyInput
#ifdef GetFrequencyInput
#undef GetFrequencyInput
#endif
#define GetFrequencyInput _gs_api_GetFrequencyInputTrampoline

//GetCounterInput
#ifdef GetCounterInput
#undef GetCounterInput
#endif
#define GetCounterInput _gs_api_GetCounterInputTrampoline

//CopyFile
#ifdef CopyFile
#undef CopyFile
#endif
#define CopyFile _gs_api_CopyFileTrampoline

//USBGetFreeSpace
#ifdef USBGetFreeSpace
#undef USBGetFreeSpace
#endif
#define USBGetFreeSpace _gs_api_USBGetFreeSpaceTrampoline

//USBUnmountStick
#ifdef USBUnmountStick
#undef USBUnmountStick
#endif
#define USBUnmountStick _gs_api_USBUnmountStickTrampoline

//GetMSTick
#ifdef GetMSTick
#undef GetMSTick
#endif
#define GetMSTick _gs_api_GetMSTickTrampoline

//SetTimer
#ifdef SetTimer
#undef SetTimer
#endif
#define SetTimer _gs_api_SetTimerTrampoline

//IsTimerOn
#ifdef IsTimerOn
#undef IsTimerOn
#endif
#define IsTimerOn _gs_api_IsTimerOnTrampoline

//IsTimerOff
#ifdef IsTimerOff
#undef IsTimerOff
#endif
#define IsTimerOff _gs_api_IsTimerOffTrampoline

//RemanentMemoryAttach
#ifdef RemanentMemoryAttach
#undef RemanentMemoryAttach
#endif
#define RemanentMemoryAttach _gs_api_RemanentMemoryAttachTrampoline

//RemanentMemoryAttachId
#ifdef RemanentMemoryAttachId
#undef RemanentMemoryAttachId
#endif
#define RemanentMemoryAttachId _gs_api_RemanentMemoryAttachIdTrampoline

//RemanentMemoryChanged
#ifdef RemanentMemoryChanged
#undef RemanentMemoryChanged
#endif
#define RemanentMemoryChanged _gs_api_RemanentMemoryChangedTrampoline

//RemanentMemoryChangedId
#ifdef RemanentMemoryChangedId
#undef RemanentMemoryChangedId
#endif
#define RemanentMemoryChangedId _gs_api_RemanentMemoryChangedIdTrampoline

//FileOpen
#ifdef FileOpen
#undef FileOpen
#endif
#define FileOpen _gs_api_FileOpenTrampoline

//FileSize
#ifdef FileSize
#undef FileSize
#endif
#define FileSize _gs_api_FileSizeTrampoline

//FileClose
#ifdef FileClose
#undef FileClose
#endif
#define FileClose _gs_api_FileCloseTrampoline

//FileWrite
#ifdef FileWrite
#undef FileWrite
#endif
#define FileWrite _gs_api_FileWriteTrampoline

//FilePrintf
#ifdef FilePrintf
#undef FilePrintf
#endif
#define FilePrintf _gs_api_FilePrintfTrampoline

//FileVPrintf
#ifdef FileVPrintf
#undef FileVPrintf
#endif
#define FileVPrintf _gs_api_FileVPrintfTrampoline

//FileRead
#ifdef FileRead
#undef FileRead
#endif
#define FileRead _gs_api_FileReadTrampoline

//FileSeek
#ifdef FileSeek
#undef FileSeek
#endif
#define FileSeek _gs_api_FileSeekTrampoline

//FileTell
#ifdef FileTell
#undef FileTell
#endif
#define FileTell _gs_api_FileTellTrampoline

//FileGets
#ifdef FileGets
#undef FileGets
#endif
#define FileGets _gs_api_FileGetsTrampoline

//FilePuts
#ifdef FilePuts
#undef FilePuts
#endif
#define FilePuts _gs_api_FilePutsTrampoline

//FileUnlink
#ifdef FileUnlink
#undef FileUnlink
#endif
#define FileUnlink _gs_api_FileUnlinkTrampoline

//FileSync
#ifdef FileSync
#undef FileSync
#endif
#define FileSync _gs_api_FileSyncTrampoline

//FileRename
#ifdef FileRename
#undef FileRename
#endif
#define FileRename _gs_api_FileRenameTrampoline

//MakeDir
#ifdef MakeDir
#undef MakeDir
#endif
#define MakeDir _gs_api_MakeDirTrampoline

//RemoveDir
#ifdef RemoveDir
#undef RemoveDir
#endif
#define RemoveDir _gs_api_RemoveDirTrampoline

//DirOpen
#ifdef DirOpen
#undef DirOpen
#endif
#define DirOpen _gs_api_DirOpenTrampoline

//DirRead
#ifdef DirRead
#undef DirRead
#endif
#define DirRead _gs_api_DirReadTrampoline

//DirClose
#ifdef DirClose
#undef DirClose
#endif
#define DirClose _gs_api_DirCloseTrampoline

//SendKeyToVisu
#ifdef SendKeyToVisu
#undef SendKeyToVisu
#endif
#define SendKeyToVisu _gs_api_SendKeyToVisuTrampoline

//SendToVisuObj
#ifdef SendToVisuObj
#undef SendToVisuObj
#endif
#define SendToVisuObj _gs_api_SendToVisuObjTrampoline

//SendKey
#ifdef SendKey
#undef SendKey
#endif
#define SendKey _gs_api_SendKeyTrampoline

//SendTouch
#ifdef SendTouch
#undef SendTouch
#endif
#define SendTouch _gs_api_SendTouchTrampoline

//SetKeyBacklight
#ifdef SetKeyBacklight
#undef SetKeyBacklight
#endif
#define SetKeyBacklight _gs_api_SetKeyBacklightTrampoline

//SetKeyBacklightColor
#ifdef SetKeyBacklightColor
#undef SetKeyBacklightColor
#endif
#define SetKeyBacklightColor _gs_api_SetKeyBacklightColorTrampoline

//SetDisplayBacklight
#ifdef SetDisplayBacklight
#undef SetDisplayBacklight
#endif
#define SetDisplayBacklight _gs_api_SetDisplayBacklightTrampoline

//SetBuzzer
#ifdef SetBuzzer
#undef SetBuzzer
#endif
#define SetBuzzer _gs_api_SetBuzzerTrampoline

//HourCounterStart
#ifdef HourCounterStart
#undef HourCounterStart
#endif
#define HourCounterStart _gs_api_HourCounterStartTrampoline

//HourCounterStop
#ifdef HourCounterStop
#undef HourCounterStop
#endif
#define HourCounterStop _gs_api_HourCounterStopTrampoline

//IsHourCounterOn
#ifdef IsHourCounterOn
#undef IsHourCounterOn
#endif
#define IsHourCounterOn _gs_api_IsHourCounterOnTrampoline

//HourCounterGet
#ifdef HourCounterGet
#undef HourCounterGet
#endif
#define HourCounterGet _gs_api_HourCounterGetTrampoline

//HourCounterSet
#ifdef HourCounterSet
#undef HourCounterSet
#endif
#define HourCounterSet _gs_api_HourCounterSetTrampoline

//GetResDataBase
#ifdef GetResDataBase
#undef GetResDataBase
#endif
#define GetResDataBase _gs_api_GetResDataBaseTrampoline

//SetProjectUpdate
#ifdef SetProjectUpdate
#undef SetProjectUpdate
#endif
#define SetProjectUpdate _gs_api_SetProjectUpdateTrampoline

//Screenshot
#ifdef Screenshot
#undef Screenshot
#endif
#define Screenshot _gs_api_ScreenshotTrampoline

//ConfigGetInt
#ifdef ConfigGetInt
#undef ConfigGetInt
#endif
#define ConfigGetInt _gs_api_ConfigGetIntTrampoline

//ConfigGetString
#ifdef ConfigGetString
#undef ConfigGetString
#endif
#define ConfigGetString _gs_api_ConfigGetStringTrampoline

//ConfigSetInt
#ifdef ConfigSetInt
#undef ConfigSetInt
#endif
#define ConfigSetInt _gs_api_ConfigSetIntTrampoline

//ConfigSetString
#ifdef ConfigSetString
#undef ConfigSetString
#endif
#define ConfigSetString _gs_api_ConfigSetStringTrampoline

//PowerCommand
#ifdef PowerCommand
#undef PowerCommand
#endif
#define PowerCommand _gs_api_PowerCommandTrampoline

//RaiseUserCEvent
#ifdef RaiseUserCEvent
#undef RaiseUserCEvent
#endif
#define RaiseUserCEvent _gs_api_RaiseUserCEventTrampoline

//strcmpi
#ifdef strcmpi
#undef strcmpi
#endif
#define strcmpi _gs_api_strcmpiTrampoline

//stricmp
#ifdef stricmp
#undef stricmp
#endif
#define stricmp _gs_api_stricmpTrampoline

//strnicmp
#ifdef strnicmp
#undef strnicmp
#endif
#define strnicmp _gs_api_strnicmpTrampoline


#endif //defined GDSPROJECT

//-----------------------------------------------------------------------------
//Datatypes
//-----------------------------------------------------------------------------

typedef void tGsFile;
typedef void tGsDir;

/**
 * Type of a directory entry
 */
typedef enum eagDirEntryType
{
    DIR_ENTRY_TYPE_FILE,
    DIR_ENTRY_TYPE_DIR,
}eGsDirEntryType;

/**
 * A directory entry
 */
typedef struct tagDirEntry
{
    eGsDirEntryType mType;  //!< Type of the entry (currently only _FILE or _DIR)
    char mName[256];        //!< Name of the entry (e.g. filename.zip)
    char mPath[256];        //!< Path of the entry (e.g. /gs/usb/filename.zip)
    uint32_t mSize;         //!< Size (valid only if mType is DIR_ENTRY_TYPE_FILE)
}tGsDirEntry;

#if defined GDSPROJECT || defined GDSAPIDRIVER || defined BUILD_USERCAPI

#define GS_USERCBITMAP_MAGIC                0x55434D00  //!< Magic value for tGsUserCBitmap

enum eAnalogInType
{
    ANALOG_IN_TYPE_NONE,                    //!< Analog input is not used
    ANALOG_IN_TYPE_OPVOLTAGE,               //!< Analog input reads the operating voltage
    ANALOG_IN_TYPE_TEMPERATUR,              //!< Analog input reads the internal device temperature
    ANALOG_IN_TYPE_0_TO_10V,                //!< Analog input is a 0-10V input
    ANALOG_IN_TYPE_0_TO_20MA,               //!< Analog input is a 0-20mA input
    ANALOG_IN_TYPE_0_TO_10V_OR_0_TO_20MA,   //!< Analog input is a 0-10V/0-20mA input (switchable)
    ANALOG_IN_TYPE_PT100,                   //!< Analog input reads a PT100
    ANALOG_IN_TYPE_ADC,                     //!< Analog input is a raw ADC input
    ANALOG_IN_TYPE_0_TO_10V_10K,            //!< Analog input is a 0-10V input with 10k input impedance
    ANALOG_IN_TYPE_0_TO_20MA_0K1,           //!< Analog input is a 0-20mA input with 100 ohm input impedance
    ANALOG_IN_TYPE_AMBIENT_LIGHT,           //!< Analog input is an ambient light sensor
    ANALOG_IN_TYPE_CURRENT_SENSE,           //!< Analog input is a current sense of an output
};

enum eDigitalOutputStatus
{
    DIG_OUT_STAT_UNKNOWN = -1,      //!< The status is unknown or status report is not supported
    DIG_OUT_STAT_OFF,               //!< The output is off (not sourcing/sinking current)
    DIG_OUT_STAT_ON,                //!< The output is on (currently sourcing/sinking current)
    DIG_OUT_STAT_OPEN_LOAD,         //!< The output is off and no load is connected
    DIG_OUT_STAT_OVERCURRENT        //!< The output is on and a short circuit is detected
};

enum eAnalogInputStatus
{
    ANA_IN_STAT_UNKNOWN = -1,      //!< The input status is unknown or status report is not supported
    ANA_IN_STAT_OK,                //!< The input status is ok
    ANA_IN_STAT_OVERCURRENT        //!< The input status detected an over current
};

typedef struct tagCanMessage
{
    uint64_t timestamp;         //!< Timestamp in nanoseconds
    uint32_t id;                //!< Id of the message
    union
    {
        uint32_t u32[2];
        int32_t  s32[2];
        uint16_t u16[4];
        int16_t  s16[4];
        uint8_t  u8[8];
        int8_t   s8[8];
    }data;
    uint8_t ext;                //!< CAN_STD_ID or CAN_EXT_ID
    uint8_t channel;            //!< The channel number
    uint8_t len;                //!< Date length code (0-8)
    uint8_t res;                //!< CAN_DATA_FRAME or CAN_RTR_FRAME
}tCanMessage;

typedef int32_t (*tCanMsgCallback)(tCanMessage * msg);

typedef struct tagSysTime
{
  uint8_t Seconds;
  uint8_t Minutes;
  uint8_t Hours;
  uint8_t Reserved;
}tSysTime;

typedef struct tagSysDate
{
  uint8_t Day;
  uint8_t Month;
  uint8_t Year;
  uint8_t DayOfWeek;
}tSysDate;

typedef struct tagGsUserCBitmap
{
    uint32_t mMagic;                //!< Magic which needs to be initialized with GS_USERCBITMAP_MAGIC
    uint32_t mChangeCount;          //!< If the bitmap changes its content/size increase this number by one
    uint32_t mW;                    //!< Width of the bitmap in pixels
    uint32_t mH;                    //!< Height of the bitmap in pixels
    uint32_t mFlags;                //!< Flags, currently always 0
    uint32_t mRes;                  //!< Reseved element, please set 0
    __extension__ uint8_t mData[];  //!< Data of the bitmap as 32 bit per pixel RGBA
}tGsUserCBitmap;


#endif //defined GDSPROJECT || defined GDSAPIDRIVER || defined BUILD_USERCAPI

//-----------------------------------------------------------------------------
//Variables
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//Function prototypes
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

//These are the functions seen by the compiler when compiling the UserC program
//or a gds driver.
#if defined GDSPROJECT || defined GDSAPIDRIVER
extern int32_t _gs_api_GetVarTrampoline(uint32_t handle);
extern int32_t _gs_api_GetVarIndexTrampoline(uint32_t handle);
extern uint32_t _gs_api_GetVarHandleTrampoline(uint32_t index);
extern int32_t _gs_api_GetVarIndexedTrampoline(uint32_t index);
extern int32_t _gs_api_SetVarTrampoline(uint32_t handle, uint32_t value);
extern int32_t _gs_api_SetVarIndexedTrampoline(uint32_t index, uint32_t value);
extern float _gs_api_GetVarFloatTrampoline(uint32_t handle);
extern int32_t _gs_api_SetVarFloatTrampoline(uint32_t handle, float value);
extern uint32_t _gs_api_GetVisibleVarsIndiecesTrampoline(uint32_t * buf, uint32_t len);
extern int32_t _gs_api_LoadParameterSetTrampoline(uint32_t varGroup, uint32_t paramSetIndex);
extern int32_t _gs_api_SaveParameterSetTrampoline(uint32_t varGroup, uint32_t paramSetIndex);
extern int32_t _gs_api_VarEnableEventTrampoline(uint32_t handle);
extern int32_t _gs_api_VarDisableEventTrampoline(uint32_t handle);
extern int32_t _gs_api_VarIsEventEnabledTrampoline(uint32_t handle);
extern void _gs_api_MsgContainerOnTrampoline(int32_t contNum);
extern void _gs_api_MsgContainerOnPosTrampoline(int32_t contNum, int32_t posX, int32_t posY);
extern void _gs_api_MsgContainerOffTrampoline(int32_t contNum);
extern void _gs_api_InfoContainerOnTrampoline(int32_t contNum);
extern void _gs_api_InfoContainerOnPosTrampoline(int32_t contNum, int32_t posX, int32_t posY);
extern void _gs_api_InfoContainerOffTrampoline(int32_t contNum);
extern uint32_t _gs_api_GetVisibleInfoContainersTrampoline(uint32_t * buf, uint32_t len);
extern void _gs_api_MaskOnTrampoline(int32_t maskNum);
extern void _gs_api_MaskOffTrampoline(int32_t maskNum);
extern void _gs_api_PrioMaskOnTrampoline(int32_t maskNum);
extern int32_t _gs_api_IsMsgContainerOnTrampoline(int32_t contNum);
extern int32_t _gs_api_IsInfoContainerOnTrampoline(int32_t contNum);
extern int32_t _gs_api_IsMaskOnTrampoline(int32_t maskNum);
extern int32_t _gs_api_ProcessMaskContainerRequestsTrampoline(void);
extern int32_t _gs_api_GetCurrentMaskShownTrampoline(void);
extern int32_t _gs_api_GetCurrentMsgContainerShownTrampoline(void);
extern void _gs_api_RTCGetTimeTrampoline(tSysTime * sysTime);
extern void _gs_api_RTCGetDateTrampoline(tSysDate * sysDate);
extern void _gs_api_RTCSetTimeTrampoline(tSysTime * sysTime);
extern void _gs_api_RTCSetDateTrampoline(tSysDate * sysDate);
extern void _gs_api_SetDebugWindowTrampoline(int32_t visible);
extern void _gs_api_PrintToDebugTrampoline(const char * fmt, ...) __attribute__((format (printf, 1, 2)));
extern void _gs_api_VPrintToDebugTrampoline(const char * fmt, va_list arg);
extern int32_t _gs_api_IsKeyDownTrampoline(int32_t keyNum);
extern int32_t _gs_api_IsAnyKeyDownTrampoline(void);
extern int32_t _gs_api_IsKeyPressedNewTrampoline(int32_t keyNum);
extern int32_t _gs_api_IsKeyReleasedNewTrampoline(int32_t keyNum);
extern int _gs_api_AddLogMessageTrampoline(const char * msg);
extern int _gs_api_AddLogVariableTrampoline(const char * msg, uint32_t handle);
extern void _gs_api_SetVideoInSourceViewportTrampoline(uint32_t channel, uint32_t x, uint32_t y, uint32_t w, uint32_t h);
extern void _gs_api_SetVideoInDestinationViewportTrampoline(uint32_t channel, uint32_t x, uint32_t y, uint32_t w, uint32_t h);
extern void _gs_api_SetVideoInParamTrampoline(uint32_t channel, const char * param, uint32_t value);
extern void _gs_api_SetVideoInOnOffTrampoline(uint32_t channel, uint32_t on);
extern int _gs_api_CANAddRxFilterCallBackTrampoline(uint32_t channel, uint32_t id, uint32_t mask, uint8_t ext, tCanMsgCallback cb);
extern int32_t _gs_api_CANCreateFiFoTrampoline(uint32_t size);
extern int32_t _gs_api_CANRemoveFiFoTrampoline(int32_t fifoId);
extern int32_t _gs_api_CANRemoveCallBackTrampoline(tCanMsgCallback cb);
extern int _gs_api_CANAddRxFilterFiFoTrampoline(uint32_t channel, uint32_t id, uint32_t mask, uint8_t ext, int32_t fifoId);
extern uint32_t _gs_api_CANReadFiFoTrampoline(int32_t fifoId, tCanMessage * msgs, uint32_t num);
extern uint32_t _gs_api_CANReadFiFoWaitTrampoline(int32_t fifoId, tCanMessage * msgs, uint32_t num);
extern uint32_t _gs_api_CANReadFiFoWaitToTrampoline(int32_t fifoId, tCanMessage * msgs, uint32_t num, uint32_t to);
extern int _gs_api_CANSendMsgTrampoline(tCanMessage * msg);
extern int _gs_api_CANSendMsgWaitTrampoline(tCanMessage * msg);
extern void _gs_api_SetVisObjDataTrampoline(uint32_t objId, const void * data, int32_t len);
extern int32_t _gs_api_GetVisObjDataTrampoline(uint32_t objId, void * data, int32_t size);
extern int _gs_api_SerialSendTrampoline(uint32_t intf, const void * data, int32_t num);
extern int32_t _gs_api_SerialRecvTrampoline(uint32_t intf, void * data, int32_t num);
extern int32_t _gs_api_SetDigitalOutputTrampoline(uint32_t num, uint32_t value);
extern int32_t _gs_api_GetDigitalOutputTrampoline(uint32_t num);
extern int32_t _gs_api_GetDigitalOutputStatusTrampoline(uint32_t num);
extern int32_t _gs_api_SetPWMOutputTrampoline(uint32_t num, uint32_t freq, uint32_t duty);
extern int32_t _gs_api_GetAnalogInputTrampoline(uint32_t num);
extern int32_t _gs_api_SetAnalogInputTypeTrampoline(uint32_t num, int32_t type);
extern int32_t _gs_api_GetAnalogInputTypeTrampoline(uint32_t num);
extern int32_t _gs_api_GetAnalogInputStatusTrampoline(uint32_t num);
extern int32_t _gs_api_SetAnalogOutputTrampoline(uint32_t num, int32_t val);
extern int32_t _gs_api_GetDigitalInputTrampoline(uint32_t num);
extern int32_t _gs_api_GetFrequencyInputTrampoline(uint32_t num);
extern int32_t _gs_api_GetCounterInputTrampoline(uint32_t num);
extern int32_t _gs_api_CopyFileTrampoline(const char * srcFile, const char * dstFile, void (*cb)(uint32_t));
extern int32_t _gs_api_USBGetFreeSpaceTrampoline(const char * path);
extern int32_t _gs_api_USBUnmountStickTrampoline(const char * path);
extern uint32_t _gs_api_GetMSTickTrampoline(void);
extern int32_t _gs_api_SetTimerTrampoline(uint32_t timer, int32_t value);
extern int32_t _gs_api_IsTimerOnTrampoline(uint32_t timer);
extern int32_t _gs_api_IsTimerOffTrampoline(uint32_t timer);
extern int32_t _gs_api_RemanentMemoryAttachTrampoline(void * mem, size_t size, int32_t automatic);
extern int32_t _gs_api_RemanentMemoryAttachIdTrampoline(uint32_t id, void * mem, size_t size, int32_t flags);
extern int32_t _gs_api_RemanentMemoryChangedTrampoline(void);
extern int32_t _gs_api_RemanentMemoryChangedIdTrampoline(uint32_t id);
extern tGsFile * _gs_api_FileOpenTrampoline(const char * name, const char * mode);
extern int32_t _gs_api_FileSizeTrampoline(const char * name);
extern void _gs_api_FileCloseTrampoline(tGsFile * fp);
extern uint32_t _gs_api_FileWriteTrampoline(const void * d, uint32_t size, uint32_t n, tGsFile * fp);
extern int32_t _gs_api_FilePrintfTrampoline(tGsFile * fp, const char * fmt, ...) __attribute__((format (printf, 2, 3)));
extern int32_t _gs_api_FileVPrintfTrampoline(tGsFile * fp, const char * fmt, va_list arg);
extern uint32_t _gs_api_FileReadTrampoline(void * d, uint32_t size, uint32_t n, tGsFile * fp);
extern int32_t _gs_api_FileSeekTrampoline(tGsFile * fp, int32_t offset, int32_t whence);
extern int32_t _gs_api_FileTellTrampoline(tGsFile * fp);
extern char * _gs_api_FileGetsTrampoline(char * s, int32_t n, tGsFile * fp);
extern int32_t _gs_api_FilePutsTrampoline(const char * s, tGsFile * fp);
extern int32_t _gs_api_FileUnlinkTrampoline(const char * name);
extern int32_t _gs_api_FileSyncTrampoline(tGsFile * fp);
extern int32_t _gs_api_FileRenameTrampoline(const char * oldName, const char * newName);
extern int32_t _gs_api_MakeDirTrampoline(const char * path);
extern int32_t _gs_api_RemoveDirTrampoline(const char * path);
extern tGsDir * _gs_api_DirOpenTrampoline(const char * path);
extern int32_t _gs_api_DirReadTrampoline(tGsDir * dir, tGsDirEntry * entry);
extern int32_t _gs_api_DirCloseTrampoline(tGsDir * dir);
extern void _gs_api_SendKeyToVisuTrampoline(uint32_t code);
extern void _gs_api_SendToVisuObjTrampoline(uint32_t objId, uint32_t code, uint32_t value);
extern void _gs_api_SendKeyTrampoline(uint32_t code, uint32_t state);
extern void _gs_api_SendTouchTrampoline(int16_t x, int16_t y, uint16_t id, uint32_t state, uint32_t dest);
extern int32_t _gs_api_SetKeyBacklightTrampoline(uint32_t n, uint32_t state);
extern int32_t _gs_api_SetKeyBacklightColorTrampoline(uint32_t n, uint16_t r, uint16_t g, uint16_t b);
extern int32_t _gs_api_SetDisplayBacklightTrampoline(uint32_t n, uint32_t intens);
extern int32_t _gs_api_SetBuzzerTrampoline(uint32_t mode, uint32_t on, uint32_t off, uint32_t count);
extern int32_t _gs_api_HourCounterStartTrampoline(uint32_t n);
extern int32_t _gs_api_HourCounterStopTrampoline(uint32_t n);
extern int32_t _gs_api_IsHourCounterOnTrampoline(uint32_t n);
extern uint32_t _gs_api_HourCounterGetTrampoline(uint32_t n);
extern uint32_t _gs_api_HourCounterSetTrampoline(uint32_t n, uint32_t val);
extern void * _gs_api_GetResDataBaseTrampoline(void);
extern int32_t _gs_api_SetProjectUpdateTrampoline(int32_t mode);
extern int32_t _gs_api_ScreenshotTrampoline(const char * path, uint32_t source);
extern int32_t _gs_api_ConfigGetIntTrampoline(const char * cfg, uint32_t * val);
extern int32_t _gs_api_ConfigGetStringTrampoline(const char * cfg, char * buf, uint32_t len);
extern int32_t _gs_api_ConfigSetIntTrampoline(const char * cfg, uint32_t val);
extern int32_t _gs_api_ConfigSetStringTrampoline(const char * cfg, const char * val);
extern int32_t _gs_api_PowerCommandTrampoline(uint32_t cmd, int32_t opt);
extern int32_t _gs_api_RaiseUserCEventTrampoline(tUserCEvt * evt);
extern int32_t _gs_api_strcmpiTrampoline(const char * s1, const char * s2);
extern int32_t _gs_api_stricmpTrampoline(const char * s1, const char * s2);
extern int32_t _gs_api_strnicmpTrampoline(const char * s1, const char * s2, size_t n);


#endif //defined GDSPROJECT || defined GDSAPIDRIVER

#ifdef GDSPROJECT
//These functions are directly from libc of the operating system. The dynamic
//linker resolves them at load time. Only declared here to satisfy the compiler.

//Prototypes for the functions which are called from libGDSProject and can be
//implemented in the UserC code.
int32_t EXPORTFROMSO UserCInit(uint32_t initFlags);
void EXPORTFROMSO UserCCycle(uint32_t evtc, tUserCEvt * evtv);
void EXPORTFROMSO UserCEvent(uint32_t evtc, tUserCEvt * evtv);
void EXPORTFROMSO UserCTimer(void);
void EXPORTFROMSO UserCDeInit(void);

#endif //defined GDSPROJECT

//These are the prototypes which should be used when generating the documentation
//for the UserC interface. All these function can be called from within the UserC
//code. The implementation of these functions are inside libGDSProject. When
//compiling the UserC shared object these prototypes are ignored.

#ifdef USERCAPI_PROTOTYPES
/**
 * Gets a project variable identified by its handle (Symbol HDL_)
 *
 * @param handle The handle of the variable as defined in the designer software
 *
 * @return The value of the variable or 0 if a variable with the given handle
 *         doesn't exists in the current project.
 */
int32_t GetVar(uint32_t handle);

/**
 * Gets the index of a given handle (to be used by SetVarIndexed/SetVarIndexed)
 *
 * @param handle The handle of the variable as defined in the designer software
 *
 * @return The index of the variable or -1 if there is no variable with handle handle
 */
int32_t GetVarIndex(uint32_t handle);

/**
 * Gets the hanlde of a given index. This is the oposite operation to GetVarIndex()
 *
 * @param index The index of the variable for which the handle will be returned
 *
 * @return The handle of the variable or 0 if index is out of range
 */
uint32_t GetVarHandle(uint32_t index);

/**
 * Gets a project variable identified by its index (Symbol IDX_)
 *
 * @param index The index of the variable (use only IDX_ symbols)
 *
 * @return The value of the variable or 0 if a variable with the given index
 *         doesn't exists in the current project.
 */
int32_t GetVarIndexed(uint32_t index);

/**
 * Sets a project variable to a given value.
 *
 * @param handle The handle of the variable as defined in the designer software
 * @param value  The value to which the variable should be set
 *
 * @return 0 if the variable given was set to the value given.
 *         -1 if the variable could not be found in the current project.
 */
int32_t SetVar(uint32_t handle, uint32_t value);

/**
 * Sets a project variable to a given value identified by its index (Symbol IDX_)
 *
 * @param index  The index of the variable (use only IDX_ symbols)
 * @param value  The value to which the variable should be set
 *
 * @return 0 if the variable given was set to the value given.
 *         -1 if the variable could not be found in the current project.
 */
int32_t SetVarIndexed(uint32_t index, uint32_t value);

/**
 * Gets a project variable in float format. If a variable is used as float
 * you should always use it with the GetVarFloat() or SetVarFloat() functions
 * and never mix the access with GetVar() and SetVar().
 *
 * @param handle The handle of the variable as defined in the designer software
 *
 * @return The value of the variable or 0.0 if a variable with the given handle
 *         doesn't exists in the current project.
 */
float GetVarFloat(uint32_t handle);

/**
 * Sets a project variable to a given value in float format. If a variable is used as float
 * you should always use it with the GetVarFloat() or SetVarFloat() functions
 * and never mix the access with GetVar() and SetVar().
 *
 * @param handle The handle of the variable as defined in the designer software
 * @param value  The value to which the variable should be set
 *
 * @return 0 if the variable given was set to the value given.
 *         -1 if the variable could not be found in the current project.
 */
int32_t SetVarFloat(uint32_t handle, float value);

/**
 * Fills a list with all currently visible variable indieces
 *
 * @note Not available on gsOpcUaServer
 *
 * @param buf Buffer which will be filled with the visible variables (May be NULL to
 *            get only the number of visible variables
 * @param len Size of the buffer in number of indieces
 *
 * @return The actual number of visible variables
 */
uint32_t GetVisibleVarsIndieces(uint32_t * buf, uint32_t len);

/**
 * Loads a parameter set of a given variable group
 *
 * @param varGroup      Variable group to load parameters for (use symbol GROUP_*).
 * @param paramSetIndex Index of parameter set which should be loaded.
 *
 * @return 0 if variables where loaded or < 0 if either varGroup or
 *         paramSetIndex was out of range.
 */
int32_t LoadParameterSet(uint32_t varGroup, uint32_t paramSetIndex);

/**
 * Saves a parameter set
 * The selected parameter set index has to be bigger than that predefined
 * in the variable table of GSe-VISU. This means that a predefined
 * parameter set can not be overwritten.
 *
 * @param varGroup      Variable group (use symbol GROUP_*)
 * @param paramSetIndex Index of the parameter set inside the variable group
 *
 * @return 0 if parameter set was saved or < 0 if an error occurred while
 *         saving the variable value.
 */
int32_t SaveParameterSet(uint32_t varGroup, uint32_t paramSetIndex);

/**
 * Enables the sending of userC events when the variable handle is changed.
 *
 * @param handle The handle for which the sending of events should be enabled
 *
 * @return 0 if sending of change events where enabled for the given handle.
 *         < 0 on error
 */
int32_t VarEnableEvent(uint32_t handle);

/**
 * Disables the sending of userC events when the variable handle is changed.
 *
 * @param handle The handle for which the sending of events should be disabled
 *
 * @return 0 if sending of change events where disable for the given handle.
 *         < 0 on error
 */
int32_t VarDisableEvent(uint32_t handle);

/**
 * Returns true if event creation for variable handle is enabled
 *
 * @param handle The handle for which the event state should be returned
 *
 * @return >0 if sending of change events are enabled for handle
 *         0  if not
 *         <0 if handle is not available
 */
int32_t VarIsEventEnabled(uint32_t handle);

/**
 * Switches a message container on. The last message container which was
 * switched on will be shown on top off all other containers.
 *
 * @param contNum Number of the container to be switched on.
 */
void MsgContainerOn(int32_t contNum);

/**
 * Switches a message container on. The last message container which was
 * switched on will be shown on top off all other containers. With this function
 * the position of the container can differ from the designed position.
 *
 * @param contNum Number of the container to be switched on.
 * @param posX    X position of the container
 * @param posY    Y position of the container
 */
void MsgContainerOnPos(int32_t contNum, int32_t posX, int32_t posY);

/**
 * Switches a message container off.
 *
 * @param contNum Number of the container to be switched off.
 */
void MsgContainerOff(int32_t contNum);

/**
 * Switches an info container on. The selected container will be shown on top of
 * all other currently enabled info containers.
 *
 * @param contNum Number of the container to be switched on.
 */
void InfoContainerOn(int32_t contNum);

/**
 * Switches an info container on. The selected container will be shown on top of
 * all other currently enabled info containers. With this function the position
 * of the container can differ from the designed position.
 *
 * @param contNum Number of the container to be switched on.
 * @param posX    X position of the container
 * @param posY    Y position of the container
 */
void InfoContainerOnPos(int32_t contNum, int32_t posX, int32_t posY);

/**
 * Switches an info container off.
 *
 * @param contNum Number of the container to be switched off.
 */
void InfoContainerOff(int32_t contNum);

/**
 * Returns a list of currently visible info containers
 *
 * @note Not available on gsOpcUaServer
 *
 * @param buf Buffer which will be filled with the visible info container numbers
 *            (May be NULL to get only the number of visible containers)
 * @param len Size of the buffer in number of container numbers
 *
 * @return The actual number of visible info containers
 */
uint32_t GetVisibleInfoContainers(uint32_t * buf, uint32_t len);

/**
 * Switches a Mask on. If the Mask is already in the mask stack it will
 * not pushed to the top.
 *
 * @param maskNum Number of the mask to be enabled
 */
void MaskOn(int32_t maskNum);

/**
 * Switches a Mask off.
 *
 * @param maskNum Number of the mask to be disabled
 */
void MaskOff(int32_t maskNum);

/**
 * Switches a Mask on. If the Mask is already in the mask stack it will
 * be pushed to the top. This is the difference to the function MaskOn
 * which will not push a mask to the top if it is already inside the stack.
 *
 * @param maskNum Number of the mask to be enabled
 */
void PrioMaskOn(int32_t maskNum);

/**
 * Checks if the given container is currently enabled as message container.
 *
 * @param contNum The number of the container to be checked
 *
 * @return Position of the container inside the stack (1 = Top (visible), 2 = Second, ...)
 *         or 0 if the given container is not in the message container stack,
 */
int32_t IsMsgContainerOn(int32_t contNum);

/**
 * Checks if the given container is currently enabled as info container.
 *
 * @param contNum The number of the container to be checked
 *
 * @return Position of the container inside the stack (1 = Top, 2 = Second, ...)
 *         or 0 if the given container is not in the info container stack,
 */
int32_t IsInfoContainerOn(int32_t contNum);

/**
 * Checks if a mask is currently inside the mask stack
 *
 * @param maskNum The number of the mask to be checked
 *
 * @return Position of the mask inside the stack (1 = Top (visible), 2 = Second, ...)
 *         or 0 if the given mask is not in the mask stack,
 */
int32_t IsMaskOn(int32_t maskNum);

/**
 * Processes all mask and container requests. This is done after each UserCCycle
 * or you can do this explicitly when doing longer stuff in your UserCCycle.
 *
 * @return The number of processed requests
 */
int32_t ProcessMaskContainerRequests(void);

/**
 * Returns the number of the currently visible mask
 *
 * @return The number of the currently visible mask
 */
int32_t GetCurrentMaskShown(void);

/**
 * Returns the number of the currently visible message container
 *
 * @return The number of the currently visible message container
 *         or -1 if no message container is visible
 */
int32_t GetCurrentMsgContainerShown(void);

/**
 * Gets the RTC time from the RTC
 *
 * @note Not available on gsOpcUaServer
 *
 * @param sysTime System time is returned into this variable
 */
void RTCGetTime(tSysTime * sysTime);

/**
 * Gets the RTC time from the RTC
 *
 * @note Not available on gsOpcUaServer
 *
 * @param sysDate System time is returned into this variable
 */
void RTCGetDate(tSysDate * sysDate);

/**
 * Sets the RTC time to the values given in argument
 *
 * @note Not available on gsOpcUaServer
 *
 * @param sysTime Sets the system time
 */
void RTCSetTime(tSysTime * sysTime);

/**
 * Sets the RTC data to the values given in argument
 *
 * @note Not available on gsOpcUaServer
 *
 * @param sysDate Sets the system time
 */
void RTCSetDate(tSysDate * sysDate);

/**
 * Sets the visibility of the debug output window
 *
 * @param visible If != 0 the debug window will be shown
 */
void SetDebugWindow(int32_t visible);

/**
 * Prints debug information to the debug window which was activated by
 * SetDebugWindow()
 *
 * @param fmt A printf like format string
 */
void PrintToDebug(const char * fmt, ...) __attribute__((format (printf, 1, 2)));

/**
 * Prints debug information to the debug window which was activated by
 * SetDebugWindow()
 *
 * @note Not available on gsOpcUaServer
 *
 * @param fmt A printf like format string
 * @param arg Variable argument list
 */
void VPrintToDebug(const char * fmt, va_list arg);

/**
 * Returns > 0 if the key with the given number is pressed. The number
 * returned represents the time from the last key press. This can be used
 * to easily detect longer key presses.
 *
 * @param keyNum Number of the key to be queried
 *
 * @return > 0 if the key with the given number is pressed
 */
int32_t IsKeyDown(int32_t keyNum);

/**
 * Returns > 0 if any key is pressed
 *
 * @return > 0 if any key is pressed
 */
int32_t IsAnyKeyDown(void);

/**
 * Returns != 0 if the key with the given number was pressed between
 * the last UserC cycle and the current one. It is only save to call
 * this function in the UserCCycle function.
 *
 * @param keyNum Number of the key to be queried
 *
 * @return > 0 if the requested key was newly pressed
 */
int32_t IsKeyPressedNew(int32_t keyNum);

/**
 * Returns != 0 if the key with the given number was released between
 * the last UserC cycle and the current one. It is only save to call
 * this function in the UserCCycle function.
 *
 * @param keyNum Number of the key to be queried
 *
 * @return > 0 if the requested key was newly released
 */
int32_t IsKeyReleasedNew(int32_t keyNum);

/**
 * Adds a log entry to the log file (if logging is enabled)
 *
 * @param msg A string with max. 28 characters which will be
 *            put into the log file
 *
 * @return 1 if log message was send
 *         0 if logging is disabled
 */
int AddLogMessage(const char * msg);

/**
 * Adds a log entry with the value of a variable to the log file
 * (if logging is enabled)
 *
 * @param msg    A string with max. 20 characters which will be
 *               put into the log file
 * @param handle The handle of the variable which should be logged
 *
 * @return 1 if log message was send
 *         0 if logging is disabled
 */
int AddLogVariable(const char * msg, uint32_t handle);

/**
 * Sets the source viewport of a video input
 *
 * @param channel The channel to be set
 * @param x       Left coordinate of the input viewport
 * @param y       Upper coordinate of the input viewport
 * @param w       Width of the input viewport
 * @param h       Height of the input viewport
 */
void SetVideoInSourceViewport(uint32_t channel, uint32_t x, uint32_t y, uint32_t w, uint32_t h);

/**
 * Sets the destination viewport of a video input
 *
 * @param channel The channel to be set
 * @param x       Left coordinate of the output viewport
 * @param y       Upper coordinate of the output viewport
 * @param w       Width of the output viewport
 * @param h       Height of the output viewport
 */
void SetVideoInDestinationViewport(uint32_t channel, uint32_t x, uint32_t y, uint32_t w, uint32_t h);

/**
 * Sets a parameter of the given video channels.
 *
 * @param channel The channel to be switched on/off
 * @param param   Name of the parameter to be set.
 *                This are the currently supported parameters:
 *                  "mirror"      Enable (value != 0) or disable (value == 0) video mirroring.
 *                  "input"       Selects one of the available video inputs for the channel
 *                  "deinterlace" Selects the deinterlace algorithm for the channel
 *                  "order"       Selects if the video is above (0) or under (1) the objects
 *                  "colorkey"    Selects the color which is transparent for order = 1
 * @param value   Value to wich the parameter should be set
 */
void SetVideoInParam(uint32_t channel, const char * param, uint32_t value);

/**
 * Switches a video channel on or off
 *
 * @param channel The channel to be switched on/off
 * @param on      If != 0 the channel will be switched on
 */
void SetVideoInOnOff(uint32_t channel, uint32_t on);

/**
 * Enables the reception of a can telegram in the userC code through a callback function.
 * To receive a can telegram you have to define a function like this:
 *
 * int32_t canReceive(tCanMessage * msg)
 * {
 *     doSomething();
 *     return 0;
 * }
 *
 * You can then call this function to register the function you have defined as above
 * to receive the CAN telegrams. It is possible to call this function multiple times
 * with the same callback function as argument. So, the same callback function can be
 * used multiple times.
 *
 * The first filter that matches will be used to call the function. If other filters
 * match they will not call their function. This behavior can be changed by oring the
 * constant GS_CAN_NON_GREEDY_FILTER into the id parameter of this function. This will
 * cause the callback function to be called when the filter matches but processing
 * doesn't stop at this point and later filters will be checked if the message
 * match and the callback function will be called for them.
 *
 * As the callback function is called directly from the receiving thread don't spend
 * much time in the callback as this can lead to lost can messages. If you have to do
 * a lot of work with the received data use the can fifo function from the cyclic part
 * of your c program.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param channel The can channel from where the message comes.
 * @param id      The id for the filter
 * @param mask    The mask for the filter
 * @param ext     != 0 if id/mask is a 29 bit id
 * @param cb      The callback function you wish to be called when a message is received
 *
 * @return 1 if the callback function was successfully registered
 */
int CANAddRxFilterCallBack(uint32_t channel, uint32_t id, uint32_t mask, uint8_t ext, tCanMsgCallback cb);

/**
 * Creates a can message fifo. The returned id can then later on used with the functions
 * CANAddRxFilterFiFo and CANReadFiFo. The fifos are removed automatically by the runtime system
 * at project shutdown or using the function CANRemoveFiFo.
 *
 * @note Not available on gsOpcUaServer
 *
 * @note Not available on gsOpcUaServer
 *
 * @param size Number of can messages the fifo can hold. This is only limited by available memory.
 *             As a default use a size of 256.
 *
 * @return The id (> 0) of the newly created fifo or -1 if the fifo could not be created.
 */
int32_t CANCreateFiFo(uint32_t size);

/**
 * Removes an existing CAN fifo and all its associated filters.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param fifoId The id of the fifo to be removed
 *
 * @return 0 if the fifo was removed successfully. != 0 othewise
 */
int32_t CANRemoveFiFo(int32_t fifoId);

/**
 * Removes an existing callback function and all its associated filters.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param cb The callback function to be removed
 *
 * @return 0 if the callback was removed successfully. != 0 othewise
 */
int32_t CANRemoveCallBack(tCanMsgCallback cb);

/**
 * Enables the reception of a can telegram in the userC code through a fifo which was
 * created with CANCreateFiFo.
 *
 * After adding a filter to a fifo you will be able to receive can messages matching the
 * given filter with the function CANReadFiFo.
 *
 * The first filter that matches will be used to pass a message to the fifo. If other filters
 * match they will not put the message to their fifo. This behavior can be changed by oring the
 * constant GS_CAN_NON_GREEDY_FILTER into the id parameter of this function. This will
 * cause the message to be put into the fifo but processing doesn't stop at this point
 * and later filters will be checked if the message match and will then put the message into
 * their fifo. This can be combinded with the callback filter so that a message will be
 * put into a fifo and also a callback function will be called.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param channel The can channel from where the message comes.
 * @param id      The id for the filter
 * @param mask    The mask for the filter
 * @param ext     != 0 if id/mask is a 29 bit id
 * @param fifoId  A fifo id returned by CANCreateFiFo or 0 if you want to use the global fifo
 *
 * @return 1 if the filter was successfully added to the given fifo.
 */
int CANAddRxFilterFiFo(uint32_t channel, uint32_t id, uint32_t mask, uint8_t ext, int32_t fifoId);

/**
 * Reads up to num messages from the given can fifo and stores them in the given array of can
 * message structures.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param fifoId Id of the fifo as returned by CANCreateFiFo or 0 if you want to use the
 *               global fifo.
 * @param msgs   A pointer to num can messages. The function will store the received can messages
 *               here.
 * @param num    Number of can messages available at msgs.
 *
 * @return The number of actual messages copied to msgs. This can be 0 or up to num.
 */
uint32_t CANReadFiFo(int32_t fifoId, tCanMessage * msgs, uint32_t num);

/**
 * Reads num messages from the given can fifo and stores them in the given array of can
 * message structures. This function will block until num messages are received.
 * In a standard environment you should always use CANReadFiFo()
 *
 * @note Not available on gsOpcUaServer
 *
 * @param fifoId Id of the fifo as returned by CANCreateFiFo or 0 if you want to use the
 *               global fifo.
 * @param msgs   A pointer to num can messages. The function will store the received can messages
 *               here.
 * @param num    Number of can messages available at msgs.
 *
 * @return The number of actual messages copied to msgs. This will be 0 or num.
 */
uint32_t CANReadFiFoWait(int32_t fifoId, tCanMessage * msgs, uint32_t num);

/**
 * Reads num messages from the given can fifo and stores them in the given array of can
 * message structures. This function will block until num messages are received or the
 * given timeout expires. If the timeout happens there can also be some messages be
 * read. Be sure to check the return value for the number of read messages.
 * In a standard environment you should always use CANReadFiFo()
 *
 * @note Not available on gsOpcUaServer
 *
 * @param fifoId Id of the fifo as returned by CANCreateFiFo or 0 if you want to use the
 *               global fifo.
 * @param msgs   A pointer to num can messages. The function will store the received can messages
 *               here.
 * @param num    Number of can messages available at msgs.
 * @param to     Timeout for the read in ms
 *
 * @return The number of actual messages copied to msgs. This will be 0 or num.
 */
uint32_t CANReadFiFoWaitTo(int32_t fifoId, tCanMessage * msgs, uint32_t num, uint32_t to);

/**
 * Sends a can message.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param msg The can message to be send
 *
 * @return 1 if the message was successfully put to the send FiFo
 */
int CANSendMsg(tCanMessage * msg);

/**
 * Sends a can message and waits until it is passed to the hardware.
 * This function is only needed in some special cases. CANSendMsg()
 * should be perfect in most cases.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param msg The can message to be send
 *
 * @return 1 if the message was successfully passed to the hardware.
 */
int CANSendMsgWait(tCanMessage * msg);

/**
 * Sets arbitrary data to visual objects. The object is identified by it's id.
 *
 * @param objId  Id of the object for which the data should be set. The interpretation
 *               of this data is totally dependent on the type of the visual object.
 * @param data   Pointer to the start of the data.
 * @param len    Length of the data. If you transmit strings don't forget to add 1
 *               to the strings length so that the string end character '\0' is included.
 */
void SetVisObjData(uint32_t objId, const void * data, int32_t len);

/**
 * Returns arbitrary data from visual objects. The object is identified by it's id.
 *
 * @param objId  Id of the object for which you want to query data. The interpretation
 *               of this data is totally dependent on the type of the visual object.
 * @param data   Pointer to the storage array where the data will be placed.
 * @param size   Number of bytes available at data.
 *
 * @return The number of bytes actually copied to data or -1 if there is no data
 *         available for the object with the requested id.
 */
int32_t GetVisObjData(uint32_t objId, void * data, int32_t size);

/**
 * Sends serial data over the given interface
 *
 * @param intf Number of the serial interface
 * @param data Data to be send
 * @param num  Number of bytes to send
 *
 * @return The number of actually send bytes. This may be smaller (or even 0)
 *         then num if the send buffer of the serial port is full.
 */
int SerialSend(uint32_t intf, const void * data, int32_t num);

/**
 * Receives data from a serial interface. This function is non-blocking. So you may
 * receive less data (even no data) then requested.
 *
 * @param intf Number of the serial interface
 * @param data Here we will store the received data
 * @param num  Number of bytes available at data
 *
 * @return Number of actually read bytes (0 to num)
 */
int32_t SerialRecv(uint32_t intf, void * data, int32_t num);

/**
 * Sets a digital output to a new value.
 *
 * @param num   Number of the digital output to be set
 * @param value New value of the digital output (0 for off, != 0 for on)
 *
 * @return 0 if the output was set to value
 *         <0 if the output could not be set (e.g. no such output)
 */
int32_t SetDigitalOutput(uint32_t num, uint32_t value);

/**
 * Gets the current value of a digital output.
 * This function returns the desired value of the output you set with
 * SetDigitalOutput(). If you need the real value of the output
 * driver you have to use GetDigitalOutputStatus()
 *
 * @param num   Number of the digital output to be queried
 *
 * @return The current value of the output
 *         <0 if the output could not be read (e.g. no such output)
 */
int32_t GetDigitalOutput(uint32_t num);

/**
 * Gets the status of a digital output.
 * Status means that the you get the real value of what the output
 * driver is currently doing. If the device supports it you can get
 * open load or short circuit state with this function
 *
 * @param num   Number of the digital output to be queried
 *
 * @return The current status of the output as a member of eDigitalOutputStatus
 *         (DIG_OUT_STAT_*) DIG_OUT_STAT_UNKNOWN may be returned if num was
 *         out of range or if the given input does not support status reporting.
 */
int32_t GetDigitalOutputStatus(uint32_t num);

/**
 * Sets a pwm output to a new value.
 *
 * @param num   Number of the pwm output to be set
 * @param freq  New value of the pwm frequency (valid range depends on the device)
 * @param duty  New value of the pwm output (0 to 1000 for a duty of 0 to 100%)
 *
 * @return 1 if the output was set to value/frequency
 */
int32_t SetPWMOutput(uint32_t num, uint32_t freq, uint32_t duty);

/**
 * Returns the current value of the analog input with the given
 * number.
 *
 * @param num   Number of the analog input to be queried
 *
 * @return A value depending on the configuration and type of the
 *         analog input. If num is out of range 0 will be returned
 */
int32_t GetAnalogInput(uint32_t num);

/**
 * Sets the type of an analog input
 *
 * @param num   Number of the analog input for which the type should be set
 * @param type  Type of the analog input
 *
 * @return 0 if the input was set to type. -1 if the input could not be set to
 *         type or num was out of range.
 */
int32_t SetAnalogInputType(uint32_t num, int32_t type);

/**
 * Get the type of an analog input
 *
 * @param num   Number of the analog input for which the type should be get
 *
 * @return Return type of the analog input.
 */
int32_t GetAnalogInputType(uint32_t num);

/**
 * Get the status of an analog input
 *
 * @param num   Number of the analog input for which the type should be get
 *
 * @return The current status of the input as a member of eAnalogInputStatus
 *         (ANA_IN_STAT_*) ANA_IN_STAT_UNKNOWN may be returned if num was
 *         out of range or if the given input does not support status reporting.
 */
int32_t GetAnalogInputStatus(uint32_t num);

/**
 * Set the given analog output to a new value
 *
 * @param num   Number of the analog input to be queried
 * @param val   The value which the analog output should take
 *
 * @return 1 if the the output was set to new value.
 *         0 if val was out of range
 *         -1 if num was out of range
 */
int32_t SetAnalogOutput(uint32_t num, int32_t val);

/**
 * Returns the current value of the digital input with the given
 * number.
 *
 * @param num   Number of the digital input to be queried
 *
 * @return 0 if the input is not active
 *         1 if the input is active
 *         -1 if the device has no such input
 */
int32_t GetDigitalInput(uint32_t num);

/**
 * Returns the current value of the frequency input with the given
 * number.
 *
 * @param num   Number of the frequency input to be queried
 *
 * @return The frequency in Hz
 *         -1 if the device has no such frequency input
 */
int32_t GetFrequencyInput(uint32_t num);

/**
 * Returns the current value of the counter input with the given
 * number.
 *
 * @param num   Number of the counter input to be queried
 *
 * @return The current count value
 *         -1 if the device has no such counter input
 */
int32_t GetCounterInput(uint32_t num);

/**
 * Generic file copy function. Files can be copied from and to any
 * subdirectory below /gs/data, /gs/usb*, /gs/ms and /tmp
 *
 * @note Not available on gsOpcUaServer
 *
 * @param srcFile  Name of the file to be copied
 * @param dstFile  Name of the destination
 * @param cb       A function like   void progress(uint32_t percent)
 *                 which will be called while the copy action is in
 *                 progress so you can show the progress of the copy
 *                 operation to the user (e.g. using a bargraph)
 *                 If this parameter is NULL the function just blocks
 *                 until the copy operation is done.
 *
 * @return 1 if the copy action was successful. 0 otherwise
 */
int32_t CopyFile(const char * srcFile, const char * dstFile, void (*cb)(uint32_t));

/**
 * Returns the free space available on the USB memory stick (if one is inserted)
 * in units of MB. Also the free space of an eventually available mass storage (/gs/ms/)
 * or the internal file system (/gs/data/) can be queried using this function.
 *
 * @param path Which USB drive you want to query (if NULL is given /gs/usb/ will be used).
 *
 * @return The number of free megabytes on an inserted USB stick or -1 if
 *         there is no stick inserted.
 */
int32_t USBGetFreeSpace(const char * path);

/**
 * Unmounts a mounted USB memory stick. This function should be called
 * before removing the stick so that it can be safely removed.
 *
 * @param path Which USB drive you want to unmount (if NULL is given /gs/usb/ will be used)
 *
 * @return 0 if the stick was unmounted successfully, > 0 if there was
 *         was an error while unmounting the stick or < 0 if there was
 *         no stick to unmount.
 */
int32_t USBUnmountStick(const char * path);

/**
 * Returns the current value of the global system timer
 * scaled in ms. This counter will overrun after 2^32ms ->
 * 49 days. Increment rate of this counter can be less
 * then 1ms.
 *
 * @return The current value of the global system timer
 */
uint32_t GetMSTick(void);

/**
 * Start or set a timer.
 *
 * @param timer Number of the timer (up to 32 are possible)
 * @param value Value of the timer in units of 1ms.
 *
 * @return 0 if the timer was set successful or < 0 otherwise
 */
int32_t SetTimer(uint32_t timer, int32_t value);

/**
 * Returns the remaining time (in ms) if the requested timer
 * is still running.
 *
 * @param timer Number of the timer (up to 32 are possible)
 *
 * @return If > 0 number of ms remaining until the time runs of.
 *         If 0 the timer has run off
 *         If < 0 timer was out of range
 */
int32_t IsTimerOn(uint32_t timer);

/**
 * Returns a value > 0 if the requested timer has run off
 *
 * @param timer Number of the timer (up to 32 are possible)
 *
 * @return If > 0 the timer has stopped
 *         If 0 the timer is still running
 *         If < 0 timer was out of range
 */
int32_t IsTimerOff(uint32_t timer);

/**
 * Attaches a piece of memory as remanent. Only one piece of memory
 * can be marked as remanent. So, if you have multiple remanent
 * variables combine them into one structure and attach that structure
 * or use RemanentMemoryAttachId
 *
 * @note Not available on gsOpcUaServer
 *
 * @param mem       Pointer to the memory you want to be remanent
 * @param size      Size of the remanent area in bytes (use sizeof operator)
 * @param automatic If set to 0 you have to call RemanentMemoryChanged() when
 *                  you have changed remanent data.
 *                  If set to 1 changed data is automatically saved to non volatile
 *                  memory. If auto mode is selected you will see a small amount of
 *                  performance decrease.
 *
 * @return 0 if the memory was successfully attached and initialized to 0
 *         1 if the memory was successfully attached and initialized with remanent values
 *         < 0 if an error occurred (e.g. out of remanent memory)
 */
int32_t RemanentMemoryAttach(void * mem, size_t size, int32_t automatic);

/**
 * Attaches a piece of memory as remanent. This function allows to attach multiple
 * remanent memories identified by an id which have to be given be the application.
 * If the id matches but the size doesn't a new attach process will be started and
 * the memory mem will be initialized with zero. The same happens when the id isn't
 * found at all.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param id        Unique id to specify which remanent memory should be used
 *                  This value have to be in the range [1,65534]. If the application
 *                  has already attached a piece of memory with the given id this function
 *                  will return GS_RMA_ALREADY_ATTACHED if NULL != mem or size != 0
 * @param mem       Pointer to the memory you want to be remanent
 *                  If this parameter is NULL and size is also 0 the allocated
 *                  memory for the given ID will be freed
 * @param size      Size of the remanent area in bytes (use sizeof operator)
 * @param flags     Flags GS_RMA_FLAG_* ored together to control the behavior of the
 *                  attached memory
 *                  GS_RMA_FLAG_AUTOMATIC: If this flag is given a change of the memory
 *                    will be detected after each UserCCycle and written to the actual
 *                    storage. Otherwise the application has to call RemanentMemoryChangedId()
 *                    to inform the runtime that the memory has to be written.
 *                  GS_RMA_FLAG_KEEP_ON_RESIZE:
 *                    If the same id is found but the size doesn't match and this flag is set
 *                    the memory will be initialized with the old values (padded with 0 or
 *                    cropped).
 *
 * @return GS_RMA_INITIALIZED       if the memory was successfully attached and initialized to 0
 *         GS_RMA_LOADED            if the memory was successfully attached and initialized with
 *                                  remanent values
 *         GS_RMA_CROPPED           Memory requested was smaller than that available,
 *                                  GS_RMA_FLAG_KEEP_ON_RESIZE was given so that some data was cropped
 *         GS_RMA_PADDED            Memory requested was bigger than that available,
 *                                  GS_RMA_FLAG_KEEP_ON_RESIZE was given so that the current data was
 *                                  padded with zero.
 *         GS_RMA_FREED             The given ID was successfully freed
 *         GS_RMA_OUT_OF_MEM        if an error occurred (e.g. out of remanent memory)
 *         GS_RMA_ERROR             The given ID couldn't be freed
 *         GS_RMA_ALREADY_ATTACHED  The given ID was already attached
 */
int32_t RemanentMemoryAttachId(uint32_t id, void * mem, size_t size, int32_t flags);

/**
 * This function has to be called if remanent memory was changed. It will then
 * store the changed memory to the non volatile memory area. This is needed when
 * the memory was not attached in automatic mode (see RemanentMemoryAttach). This
 * function behaves as if RemanentMemoryChangedId is called with an id of 0.
 *
 * @return Currently always 0
 */
int32_t RemanentMemoryChanged(void);

/**
 * This function has to be called if remanent memory was changed. It will then
 * store the changed memory to the non volatile memory area. This is needed when
 * the memory was not attached in automatic mode (see RemanentMemoryAttachId)
 *
 * @param id        Unique id to specify which remanent memory has changed
 *
 * @return Currently always 0
 */
int32_t RemanentMemoryChangedId(uint32_t id);

/**
 * Opens a file. You can access files on USB drives (/gs/usb),
 * internal data storage (/gs/data), internal mass storage (/gs/ms) or
 * on temporary storage (/tmp)
 *
 * @param name Name of the file to be opened
 * @param mode File mode ("r" for reading, "w" for writing, "a" for append)
 *
 * @return NULL or a valid file pointer
 */
tGsFile * FileOpen(const char * name, const char * mode);

/**
 * Returns the size of a file
 *
 * @param name Name of the file for which the size should be returned
 *
 * @return Size of the file in bytes or a value < 0 if the file didn't exists
 */
int32_t FileSize(const char * name);

/**
 * Closes a file opened by FileOpen
 *
 * @param fp A pointer returned by FileOpen
 */
void FileClose(tGsFile * fp);

/**
 * Writes arbitrary data to a file
 *
 * @param d    Pointer to the data you want to write
 * @param size Size of one element to write
 * @param n    Number of elements to be written
 * @param fp   File pointer as returned by FileOpen
 *
 * @return The number of elements actually written. If n is returned
 *         the write was a full success.
 */
uint32_t FileWrite(const void * d, uint32_t size, uint32_t n, tGsFile * fp);

/**
 * Writes printf like to a file
 *
 * @param fp   File pointer as returned by FileOpen
 * @param fmt  Pointer to the data you want to write
 *
 * @return The number bytes written to the file
 */
int32_t FilePrintf(tGsFile * fp, const char * fmt, ...) __attribute__((format (printf, 2, 3)));

/**
 * Writes printf like to a file
 *
 * @note Not available on gsOpcUaServer
 *
 * @param fp   File pointer as returned by FileOpen
 * @param fmt  Pointer to the data you want to write
 * @param arg Variable argument list
 *
 * @return The number bytes written to the file
 */
int32_t FileVPrintf(tGsFile * fp, const char * fmt, va_list arg);

/**
 * Writes arbitrary data from a file
 *
 * @param d    Where the data will be placed (must be big enough for size * n bytes)
 * @param size Size of one element to be read
 * @param n    Number of elements to be read
 * @param fp   File pointer as returned by FileOpen
 *
 * @return The number of elements actually read. If n is returned
 *         the read was a full success.
 */
uint32_t FileRead(void * d, uint32_t size, uint32_t n, tGsFile * fp);

/**
 * Moves the file pointer of an opened file around
 *
 * @param fp     File pointer as returned by FileOpen
 * @param offset Offset by which the file pointer should be moved
 * @param whence GS_FILE_SEEK_SET, GS_FILE_SEEK_CUR or GS_FILE_SEEK_END
 *               to select from where offset counts
 *
 * @return 0 on success or != 0 if an error occurred
 */
int32_t FileSeek(tGsFile * fp, int32_t offset, int32_t whence);

/**
 * Returns the current position of the file pointer of an opened file
 *
 * @param fp     File pointer as returned by FileOpen
 *
 * @return Offset of fp inside the current file
 */
int32_t FileTell(tGsFile * fp);

/**
 * Reads characters from an opened file until one of the following conditions is met:
 *  - \n is encountered
 *  - EOF is reached
 *  - n bytes a read
 *
 * @param s  Target of the read bytes
 * @param n  Maximum number of bytes to be read
 * @param fp File pointer as returned by FileOpen
 *
 * @return s if the read was successful or NULL if EOF was reached
 */
char * FileGets(char * s, int32_t n, tGsFile * fp);

/**
 * Writes a string to a file stream.
 *
 * @param s  The string to be written
 * @param fp File pointer as returned by FileOpen
 *
 * @return A positive (>= 0) number on success
 */
int32_t FilePuts(const char * s, tGsFile * fp);

/**
 * Unlinks (deletes) a file
 *
 * @param name Name of the file to be unlinked
 *
 * @return 0 on success or != 0 if an error occurred
 */
int32_t FileUnlink(const char * name);

/**
 * Makes sure that the content of a file is written to the
 * underlaying storage medium.
 *
 * @param fp File pointer as returned by FileOpen. If NULL
 *           is passed all data (for all files) which is
 *           not written to the storage medium will be
 *           written.
 *
 * @return 0 on success or != 0 if an error occurred
 */
int32_t FileSync(tGsFile * fp);

/**
 * Renames a file
 *
 * @param oldName Old name of the file
 * @param newName New name of the file
 *
 * @return 0 on success or != 0 if an error occurred
 */
int32_t FileRename(const char * oldName, const char * newName);

/**
 * Creates a directory on the USB stick or in internal memory
 *
 * @param path Directory to be created
 *
 * @return 0 if the directory was successfully created
 */
int32_t MakeDir(const char * path);

/**
 * Removes a directory from the USB stick or from internal memory
 *
 * @param path Directory to be removed
 *
 * @return 0 if the directory was successfully removed
 */
int32_t RemoveDir(const char * path);

/**
 * Opens a directory stream for reading
 *
 * @note Not available on gsOpcUaServer
 *
 * @param path Directory to be opened
 *
 * @return != NULL if the directory was successfully opened
 */
tGsDir * DirOpen(const char * path);

/**
 * Opens a directory stream for reading
 *
 * @note Not available on gsOpcUaServer
 *
 * @param dir   The directory stream opened by DirOpen
 * @param entry Structure that will be filled with informations
 *
 * @return 0 if entry was filled with new directory data
 */
int32_t DirRead(tGsDir * dir, tGsDirEntry * entry);

/**
 * Closes a directory stream
 *
 * @note Not available on gsOpcUaServer
 *
 * @param dir The directory stream to be closed
 *
 * @return 0 on success
 */
int32_t DirClose(tGsDir * dir);

/**
 * Sends a key code to the visualization. This can be used to control
 * the cursor position. The exact behavior of the function is controller
 * through various bits in the code parameter.
 *
 * @param code The key code you want to send. You can use the following
 *             macros to simulate various operations
 *             GS_KEY_TO_VISU_DOWNUP(k)  Send a down->up sequence for key k
 *             GS_KEY_TO_VISU_DOWN(k)    Send a down for key k
 *             GS_KEY_TO_VISU_UP(k)      Send a up for key k
 *             GS_KEY_TO_VISU_UPDOWN(k)  Send a up->down sequence for key k
 *             GS_KEY_TO_VISU_REPEAT(k)  Send a repeat for key k
 *
 *             The parameter k of the above macros can contain different
 *             flags depending on what you want to send.
 *             GS_KEY_TO_VISU_TYPE_KEY     A standard key
 *             GS_KEY_TO_VISU_TYPE_LKF     A logical key function
 *             GS_KEY_TO_VISU_TYPE_UNICODE A unicode character
 *
 *             A complete example would then look like
 *             SendKeyToVisu(GS_KEY_TO_VISU_DOWNUP(GS_KEY_TO_VISU_TYPE_UNICODE | 'A');
 *             This sends an uppercase 'A' to the visualization.
 */
void SendKeyToVisu(uint32_t code);

/**
 * Sends a message to a visual object. This function is generic interface to
 * implement special behavior for visual objects an can be used in different ways.
 *
 * @param objId The id of the object the message should be send to
 * @param code  The operation code for what should be send to the object
 *                GS_TO_VISU_OBJ_SELECT  Put the given object id into selected mode
 * @param value Some operations support an additional value to be attached to
 *              the message.
 */
void SendToVisuObj(uint32_t objId, uint32_t code, uint32_t value);

/**
 * Sends a key to the key handling system. State tells the system if the key
 * was pressed or released. Be aware that a press doesn't work if the key is
 * already down.
 *
 * @param code  The key code you want to send
 * @param state The state of the key (GS_SEND_KEY_UP/GS_SEND_KEY_DOWN)
 */
void SendKey(uint32_t code, uint32_t state);

/**
 * Sends a display touch to the key handling system. State tells the system
 * if the display was touched, hold or released.
 *
 * @param x     The X coordinate
 * @param y     The Y coordinate
 * @param id    The touch ID (multi touch)
 * @param state The state of the key (GS_SEND_TOUCH_UP/GS_SEND_TOUCH_DOWN/GS_SEND_TOUCH_ON)
 * @param dest  The destination (send to VISU and/or send to CTRL)
 */
void SendTouch(int16_t x, int16_t y, uint16_t id, uint32_t state, uint32_t dest);

/**
 * Sets the state of the backlight of a key. The exact behavior of the
 * keyboard depends on the actual hardware.
 *
 * @param n     Number of the key. (0 for devices with only global backlight)
 * @param state New state of the key backlight
 *
 * @return > 0 if the backlight was set successfully or < 0 if there was an
 *         error.
 */
int32_t SetKeyBacklight(uint32_t n, uint32_t state);

/**
 * Sets the color of the backlight of a key. The exact behavior of the
 * keyboard depends on the actual hardware.
 *
 * @param n Number of the key. (0 for setting the color of all keys)
 * @param r The RED value of the color (0..65535)
 * @param g The GREEN value of the color (0..65535)
 * @param b The BLUE value of the color (0..65535)
 *
 * @return 0 if the backlight color was set successfully or < 0 if there was an
 *         error.
 */
int32_t SetKeyBacklightColor(uint32_t n, uint16_t r, uint16_t g, uint16_t b);

/**
 * Sets the state of the backlight of a display.
 *
 * @param n      Number of the display. (0 for devices with only one display)
 * @param intens A value between 0 and 1000 where 0 is lowest intensity and
 *               1000 is highest
 *
 * @return 0 if the backlight was set successfully or < 0 if there was an
 *         error.
 */
int32_t SetDisplayBacklight(uint32_t n, uint32_t intens);

/**
 * If the device has a buzzer its behavior can be set using this function.
 * Not every device supports the quiet/loud setting.
 *
 * @param mode  0 = off, 1 = on(quiet), 2 = on(loud) The actual meaning of loud
 *              depends on the device. If the device is only capable of producing
 *              one intensity loud will be identical with quiet.
 * @param on    Time while the buzzer is on (in steps of 10ms, max. 30000)
 * @param off   Time while the buzzer is off (in steps of 10ms, max. 30000)
 * @param count Number of repetitions (endless if 0, max. 30000)
 *
 * @return >= 0 if the buzzer mode could be set successfully. < 0 if an error
 *         occurred or the device has no buzzer.
 */
int32_t SetBuzzer(uint32_t mode, uint32_t on, uint32_t off, uint32_t count);

/**
 * Starts a hour counter. Up to 32 hour counters are available.
 *
 * @param n The number of the hour counter to be started.
 *          Hour counter 0 will run always.
 *
 * @return 0 if the counter was started. -1 if n was out of range.
 */
int32_t HourCounterStart(uint32_t n);

/**
 * Stops a hour counter. Up to 32 hour counters are available.
 *
 * @param n The number of the hour counter to be stopped.
 *          Hour counter 0 will run always.
 *
 * @return 0 if the counter was started. -1 if n was out of range or the
 *         given counter could not be stopped.
 */
int32_t HourCounterStop(uint32_t n);

/**
 * Returns a value != 0 if hour counter n is currently running.
 *
 * @param n The number of the hour counter you want to query
 *
 * @return A value != 0 if hour counter n is currently running.
 */
int32_t IsHourCounterOn(uint32_t n);

/**
 * Returns the value of the given hour counter
 *
 * @param n The number of the hour counter you want to query
 *
 * @return The number of seconds on the hour counter queried or 0 if
 *         n is out of range.
 */
uint32_t HourCounterGet(uint32_t n);

/**
 * Sets a value to a given hour counter. Hour counters 0 and 1 can not
 * be set to a new value.
 *
 * @param n   The number of the hour counter you want to set
 * @param val The value you want to set the hour counter to (scaled in seconds)
 *
 * @return 0 if the counter was set successfully or -1 if n was out of range
 */
uint32_t HourCounterSet(uint32_t n, uint32_t val);

/**
 * Returns a pointer to the base address of the resource file of the project.
 * This can be used to access resource data (e.g. Texts, Bitmaps, ...) from
 * the UserC program. You can't do anything with this without additional
 * informations supplied by GSe-VISU.
 *
 * @note Not available on gsOpcUaServer
 *
 * @return A pointer to the beginning of RESDATA.BIN file in memory
 */
void * GetResDataBase(void);

/**
 * If a project update was requested you can disable its processing
 * using this function. If you are later ready to allow a project
 * update this can be also done using this function. You can also
 * request a project update by passing GS_PRJ_UPDATE_TRIGGER to
 * the function.
 *
 * @param mode GS_PRJ_UPDATE_TRIGGER to request a project update
 *             GS_PRJ_UPDATE_REJECT if the update should not be performed
 *             GS_PRJ_UPDATE_ACCEPT if the update should be performed
 *
 * @return 0 if the call changed the project update handling successfully
 */
int32_t SetProjectUpdate(int32_t mode);

/**
 * Takes a screenshot. File format of the resulting file can be PNG or JPG
 * depending on the file extension. As taking a screenshot is an asynchronous
 * function the function will return immediately. Path can only be on a
 * connected USB memory. Taking screenshots to internal memory is not
 * supported. If path contains the string "%s" this will be replaced with
 * a timedate string of format "YYMMDD_HHMMSS".
 *
 * @param path   Path and filename of the screenshot. Give a proper ending (.png or .jpg)
 * @param source May be any of GS_SCREENSHOT_SRC_*
 *
 * @return 0 if function was called with valid parameters and a screenshot will
 *         be created.
 */
int32_t Screenshot(const char * path, uint32_t source);

/**
 * Get an integer parameter from the system configuration. This function is
 * mainly used by code which is generated by GSe-VISU. Therefore there
 * is no detailed documentation about the possible parameters.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param cfg Name of the configuration entry
 * @param val The requested value will be put here if found successfully
 *
 * @return 0 if val was updated with the configuration value requested with
 *         cfg.
 */
int32_t ConfigGetInt(const char * cfg, uint32_t * val);

/**
 * Get a string parameter from the system configuration. This function is
 * mainly used by code which is generated by GSe-VISU. Therefore there
 * is no detailed documentation about the possible parameters.
 *
 * @param cfg Name of the configuration entry
 * @param buf The requested string will be put here if found successfully
 * @param len Length of the buffer provided
 *
 * @return 0 if buf was updated with the configuration value requested with
 *         cfg.
 */
int32_t ConfigGetString(const char * cfg, char * buf, uint32_t len);

/**
 * Set an integer parameter of the system configuration. The changed configuration
 * will be used after a controlled restart of the device.
 *
 * There is currently no documentation about the possible parameters as this
 * function is used by generated code from GSe-VISU only.
 *
 * @param cfg Name of the configuration entry
 * @param val The value which should be written.
 *
 * @return 0 if val was successfully written to the system configuration.
 */
int32_t ConfigSetInt(const char * cfg, uint32_t val);

/**
 * Set a string parameter of the system configuration. The changed configuration
 * will be used after a controlled restart of the device.
 *
 * @param cfg Name of the configuration entry
 * @param val The value which should be written.
 *
 * @return 0 if val was successfully written to the system configuration.
 */
int32_t ConfigSetString(const char * cfg, const char * val);

/**
 * With this function commands can be issued to the system which influences the
 * power consumption of the device. Only GS_POWER_CMD_* symbols should be passed
 * to the function. Not all devices are supporting all commands. Some devices
 * may support no commands at all. Some commands may influence project execution
 * from a simple performance impact up to a total execution halt.
 *
 * @param cmd The power command you wan't to issue to the operating system
 * @param opt Some commands may need an optional parameter which is passed in here.
 *
 * @return 0 if the command was successfully executed. Any other value indicates
 *         an error.
 */
int32_t PowerCommand(uint32_t cmd, int32_t opt);

/**
 * Sends an arbitrary UserC event.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param evt Pointer to an event structure.
 *
 * @return 0 if the event was successfully send.
 */
int32_t RaiseUserCEvent(tUserCEvt * evt);

/**
 * Compares two strings ignoring upper / lowercase
 * The strcmpi() function is identical to the stricmp() function.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param s1 First string to compare
 * @param s2 Second string to compare
 *
 * @return < 0 s1 is less than s2
 *           0 s1 is equal to s2
 *         > 0 s1 is greater than s2
 */
int32_t strcmpi(const char * s1, const char * s2);

/**
 * Compares two strings ignoring upper / lowercase
 * The stricmp() function is identical to the strcmpi() function.
 *
 * @note Not available on gsOpcUaServer
 *
 * @param s1 First string to compare
 * @param s2 Second string to compare
 *
 * @return < 0 s1 is less than s2
 *           0 s1 is equal to s2
 *         > 0 s1 is greater than s2
 */
int32_t stricmp(const char * s1, const char * s2);

/**
 * Compares two strings up to a given length ignoring upper / lowercase
 *
 * @note Not available on gsOpcUaServer
 *
 * @param s1 First string to compare
 * @param s2 Second string to compare
 * @param n The maximum number of characters that you want to compare
 *
 * @return < 0 s1 is less than s2
 *           0 s1 is equal to s2
 *         > 0 s1 is greater than s2
 */
int32_t strnicmp(const char * s1, const char * s2, size_t n);


#endif //USERCAPI_PROTOTYPES

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //USERCAPI_H_INCLUDED
//-----------------------------------------------------------------------------
//EOF
//-----------------------------------------------------------------------------
